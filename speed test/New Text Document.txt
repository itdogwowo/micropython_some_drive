import json
import framebuf
import jpeg
import os
import _thread
import time

class ResourceBuffer:
    """雙重緩衝資源管理器 - 性能優化版"""
    
    def __init__(self, name, root_path, config, decoder, strict_mode=False):
        """
        初始化資源緩衝
        Args:
            name: 資源名稱
            root_path: 根路徑
            config: 資源配置
            decoder: JPEG解碼器
            strict_mode: 嚴格模式,啟用文件檢查(調試用)
        """
        self.name = name
        self.root_path = root_path
        self.config = config
        self.decoder = decoder
        self.strict_mode = strict_mode
        
        # 提取配置
        self.width = config['width']
        self.height = config['height']
        self.x = config['x']
        self.y = config['y']
        self.depth = config['depth']
        
        # 預計算固定值
        self.buffer_size = self.width * self.height * 2  # RGB565
        self.jpeg_max_size = self.width * self.height * 4
        
        # 當前幀索引
        self.current_frame = 0
        self.next_frame_index = 0
        
        # === 雙重緩衝設計 ===
        self.front_buffer = bytearray(self.buffer_size)
        self.back_buffer = bytearray(self.buffer_size)
        
        # 預創建memoryview(避免重複創建)
        self.front_mv = memoryview(self.front_buffer)
        self.back_mv = memoryview(self.back_buffer)
        
        self.front_fb = framebuf.FrameBuffer(
            self.front_buffer,
            self.width,
            self.height,
            framebuf.RGB565
        )
        
        self.back_fb = framebuf.FrameBuffer(
            self.back_buffer,
            self.width,
            self.height,
            framebuf.RGB565
        )
        
        # JPEG讀取緩衝
        self.jpeg_buffer = bytearray(self.jpeg_max_size)
        self.jpeg_mv = memoryview(self.jpeg_buffer)
        
        # === 多核同步機制 ===
        self.decode_lock = _thread.allocate_lock()
        self.swap_lock = _thread.allocate_lock()
        self.decode_ready = False
        self.decode_thread_running = False
        
        # 初始化第一幀到前台
        self._load_frame_sync(0, self.front_buffer, self.front_mv)
        
        # 預載第二幀到後台(如果有多幀)
        if self.depth > 1:
            self._start_background_decode(1)
    
    def _get_file_path(self, frame_index):
        """構建文件路徑"""
        return f"{self.root_path}{self.name}/{frame_index:03d}.jpeg"
    
    def _calculate_next_index(self, current_idx):
        """計算下一幀索引"""
        return (current_idx + 1) % self.depth
    
    def _load_frame_sync(self, frame_index, target_buffer, target_mv):
        """同步載入指定幀到目標緩衝區"""
        try:
            file_path = self._get_file_path(frame_index)
            
            # 讀取JPEG數據
            with open(file_path, "rb") as f:
                f.readinto(self.jpeg_mv)
            
            # 解碼
            decoded_data = self.decoder.decode(self.jpeg_buffer)
            
            # 使用預創建的memoryview快速拷貝
            decoded_mv = memoryview(decoded_data)
            target_mv[:self.buffer_size] = decoded_mv[:self.buffer_size]
            
            return True
            
        except OSError as e:
            print(f"[ERROR] Failed to load {file_path}: {e}")
            if self.strict_mode:
                raise
            return False
            
        except Exception as e:
            print(f"[ERROR] Decode error for frame {frame_index}: {e}")
            return False
    
    def _decode_worker(self, frame_index):
        """後台解碼工作線程"""
        try:
            success = self._load_frame_sync(
                frame_index, 
                self.back_buffer, 
                self.back_mv
            )
            
            with self.decode_lock:
                if success:
                    self.decode_ready = True
                    self.next_frame_index = frame_index
                else:
                    self.decode_ready = False
                
        except Exception as e:
            print(f"[WORKER] Decode error: {e}")
            with self.decode_lock:
                self.decode_ready = False
        
        finally:
            self.decode_thread_running = False
    
    def _start_background_decode(self, frame_index):
        """啟動後台解碼"""
        if frame_index >= self.depth:
            return False
        
        # 等待上一次解碼完成
        timeout = 0
        while self.decode_thread_running and timeout < 100:
            time.sleep_ms(1)
            timeout += 1
        
        if self.decode_thread_running:
            print(f"[WARN] Previous decode still running for {self.name}")
            return False
        
        # 重置狀態
        with self.decode_lock:
            self.decode_ready = False
            self.decode_thread_running = True
        
        # 啟動新線程
        try:
            _thread.start_new_thread(self._decode_worker, (frame_index,))
            return True
        except Exception as e:
            print(f"[ERROR] Failed to start decode thread: {e}")
            self.decode_thread_running = False
            return False
    
    def _swap_buffers(self):
        """交換前後台緩衝"""
        with self.swap_lock:
            # 交換buffer引用
            self.front_buffer, self.back_buffer = self.back_buffer, self.front_buffer
            
            # 交換memoryview
            self.front_mv, self.back_mv =  self.back_mv, self.front_mv
            
            # 交換framebuffer
            self.front_fb = framebuf.FrameBuffer(
                self.front_buffer,
                self.width,
                self.height,
                framebuf.RGB565
            )
            self.back_fb = framebuf.FrameBuffer(
                self.back_buffer,
                self.width,
                self.height,
                framebuf.RGB565
            )
    
    def get_current_buffer(self):
        """獲取當前幀緩衝"""
        return self.front_fb
    
    def get_next_frame(self):
        """獲取下一幀(非阻塞)"""
        if self.depth <= 1:
            return self.front_fb
        
        # 檢查後台解碼是否完成
        is_ready = False
        with self.decode_lock:
            is_ready = self.decode_ready
        
        if is_ready:
            # 執行交換
            self._swap_buffers()
            
            with self.decode_lock:
                self.current_frame = self.next_frame_index
                self.decode_ready = False
            
            # 立即啟動下一幀解碼
            next_idx = self._calculate_next_index(self.current_frame)
            self._start_background_decode(next_idx)
        
        return self.front_fb
    
    def jump_to_frame(self, frame_index):
        """跳轉到指定幀"""
        if not (0 <= frame_index < self.depth):
            print(f"[WARN] Invalid frame {frame_index}, range: 0-{self.depth-1}")
            return self.front_fb
        
        # 等待當前解碼完成
        timeout = 0
        while self.decode_thread_running and timeout < 100:
            time.sleep_ms(1)
            timeout += 1
        
        # 同步載入到前台
        if self._load_frame_sync(frame_index, self.front_buffer, self.front_mv):
            self.current_frame = frame_index
            
            # 重建framebuffer
            self.front_fb = framebuf.FrameBuffer(
                self.front_buffer,
                self.width,
                self.height,
                framebuf.RGB565
            )
            
            # 預載下一幀
            if self.depth > 1:
                next_idx = self._calculate_next_index(frame_index)
                self._start_background_decode(next_idx)
        
        return self.front_fb
    
    def get_digit_buffer(self, digit):
        """獲取數字圖像(專門為text資源)"""
        if self.name != 'text':
            return None
        
        if not (0 <= digit <= self.depth):
            print(f"[WARN] Invalid digit {digit}")
            return None
        
        # 等待解碼線程完成
        timeout = 0
        while self.decode_thread_running and timeout < 100:
            time.sleep_ms(1)
            timeout += 1
        
        # 載入數字到前台
        if self._load_frame_sync(digit, self.front_buffer, self.front_mv):
            self.front_fb = framebuf.FrameBuffer(
                self.front_buffer,
                self.width,
                self.height,
                framebuf.RGB565
            )
            return self.front_fb
        
        return None
    
    def reset(self):
        """重置到第一幀"""
        timeout = 0
        while self.decode_thread_running and timeout < 100:
            time.sleep_ms(1)
            timeout += 1
        
        self.current_frame = 0
        self._load_frame_sync(0, self.front_buffer, self.front_mv)
        
        # 重建framebuffer
        self.front_fb = framebuf.FrameBuffer(
            self.front_buffer,
            self.width,
            self.height,
            framebuf.RGB565
        )
        
        # 預載下一幀
        if self.depth > 1:
            self._start_background_decode(1)
    
    def cleanup(self):
        """清理資源"""
        timeout = 0
        while self.decode_thread_running and timeout < 200:
            time.sleep_ms(5)
            timeout += 1


class JpegBufferController:
    """JPEG圖像緩衝管理器 - 處理所有圖像資源的讀取和緩衝"""
    
    def __init__(self, root_path, config_file='dp_config.json', strict_mode=False):
        """
        初始化緩衝管理器
        Args:
            root_path: 資源根目錄路徑
            config_file: 配置文件名
            strict_mode: 嚴格模式(調試用)
        """
        self.root_path = root_path.rstrip('/') + '/'
        self.config_file = config_file
        self.strict_mode = strict_mode
        self.config = {}
        self.resources = {}
        
        # 創建共享的JPEG解碼器
        self.decoder = jpeg.Decoder(rotation=0, pixel_format="RGB565_BE")
        
        # 讀取配置文件
        self._load_config(config_file)
        
        # 初始化所有資源
        self._init_resources()
    
    def _load_config(self, config_file):
        """載入配置文件"""
        config_path = self.root_path + config_file
        try:
            with open(config_path, 'r') as f:
                self.config = json.load(f)
            print(f"✓ Config loaded from {config_path}")
        except Exception as e:
            print(f"✗ Failed to load config: {e}")
            raise
    
    def _init_resources(self):
        """初始化所有資源"""
        
#         for name, cfg in self.config.items():
            
        for i in self.config['display_Layout']:
            name = i["type"]
            self.resources[name] = ResourceBuffer(
                    name=name,
                    root_path=self.root_path,
                    config=i,
                    decoder=self.decoder,
                    strict_mode=self.strict_mode
                )
            print(f"✓ Initialized resource: {name} ({i['depth']} frames)")
            
            if name == 'text':
                self._init_text(i)
            
        self.counter_time = self.config['counter_time']
        
    
    def _init_text(self, text_cfg):
        """初始化時間顯示緩衝 - 預載所有數字圖像"""
        self.seconds = -1
        
        # === 預載數字圖像緩存 (0-9 + 冒號) ===
        self._digit_cache = {}
        text_resource = self.resources['text']
        
        # 預載 0-9 和冒號(索引10)
        for digit in range(11):  # 0-9 + 冒號
            # 從 ResourceBuffer 獲取數字圖像
            digit_fb = text_resource.get_digit_buffer(digit)
            
            if digit_fb:
                # 創建獨立的緩存副本
                buffer_size = text_cfg['width'] * text_cfg['height'] * 2
                cached_data = bytearray(buffer_size)
                cached_fb = framebuf.FrameBuffer(
                    cached_data,
                    text_cfg['width'],
                    text_cfg['height'],
                    framebuf.RGB565
                )

                # 從 ResourceBuffer 複製圖像數據

                cached_fb.blit(digit_fb, 0, 0)
                
                self._digit_cache[digit] = {
                    'buff': cached_fb,
                    'data': cached_data
                }
                
                digit_text = digit if digit < 10 else ':'
                print(f"  ✓ Cached digit: {digit_text}")
            else:
                print(f"  ✗ Failed to cache digit: {digit}")
        
        # === 創建5個位置的顯示緩衝區 ===
        self._time_buffer = {}
        for i in range(5):
            buffer_size = text_cfg['width'] * text_cfg['height'] * 2
            buffer_data = bytearray(buffer_size)
            _buffer = framebuf.FrameBuffer(
                buffer_data,
                text_cfg['width'],
                text_cfg['height'],
                framebuf.RGB565
            )
            self._time_buffer[str(i)] = {
                'buff': _buffer,
                'data': buffer_data,
                'status': 255  # 初始狀態設為無效值
            }
        
        # === 創建完整時間顯示緩衝 ===
        total_size = text_cfg['width'] * 5 * text_cfg['height'] * 2
        self.time_buffer_data = bytearray(total_size)
        self.time_buffer = framebuf.FrameBuffer(
            self.time_buffer_data,
            text_cfg['width'] * 5,
            text_cfg['height'],
            framebuf.RGB565
        )
        
        print(f"✓ Time display initialized: {text_cfg['width']*5}x{text_cfg['height']}")
        print(f"✓ Digit cache: {len(self._digit_cache)} images loaded")
                

    
    def reinitialize(self, new_root_path, config_file=None):
        """
        重新初始化資源管理器
        Args:
            new_root_path: 新的資源根目錄路徑
            config_file: 可選的新配置文件名
        """
        # 正規化新路徑
        new_root_path = new_root_path.rstrip('/') + '/'
        
        # 保存舊值以便恢復
        old_root_path = self.root_path
        old_config_file = self.config_file
        
        # 更新實例變量
        self.root_path = new_root_path
        if config_file is not None:
            self.config_file = config_file
        
        try:
            # 嘗試加載新配置
            self._load_config(self.config_file)
        except Exception as e:
            # 加載失敗,恢復舊值
            self.root_path = old_root_path
            self.config_file = old_config_file
            print(f"✗ Reinitialization failed: {e}")
            raise
        
        # 清理舊資源
        for resource in self.resources.values():
            resource.cleanup()
        
        self.resources = {}
        
        # 清理文本緩衝區
        if hasattr(self, 'time_buffer'):
            del self.time_buffer
        if hasattr(self, '_time_buffer'):
            del self._time_buffer
        if hasattr(self, 'seconds'):
            del self.seconds
        
        # 重新初始化資源
        self._init_resources()
        print("✓ Reinitialization completed successfully")
    
    def get_background(self):
        """獲取背景圖像緩衝"""
        if 'background' in self.resources:
            return self.resources['background'].get_current_buffer()
        return None
    
    def get_next_frame(self, resource_name):
        """
        獲取指定資源的下一幀
        Args:
            resource_name: 資源名稱
        Returns:
            framebuf對象或None
        """
        if resource_name in self.resources:
            return self.resources[resource_name].get_next_frame()
        return None
    
    def jump_to_frame(self, resource_name, frame_index):
        """
        跳轉到指定資源的特定幀
        Args:
            resource_name: 資源名稱
            frame_index: 幀索引
        Returns:
            framebuf對象或None
        """
        if resource_name in self.resources:
            return self.resources[resource_name].jump_to_frame(frame_index)
        return None


    def update_time_display(self, seconds):
        """
        更新時間顯示緩衝區 - 使用預載緩存
        Args:
            seconds: 秒數
        Returns:
            包含完整時間顯示的framebuf
        """
        if not self.time_buffer or 'text' not in self.resources:
            return None
        
        if self.seconds == seconds:
            return self.time_buffer  # 時間未變化,直接返回
        
        self.seconds = seconds
        mins, secs = divmod(seconds, 60)
        
        text_cfg = self.resources['text'].config
        digit_width = text_cfg['width']
        
        # 預計算字符映射
        digits = [
            mins // 10,        # 十位分鐘
            mins % 10,         # 個位分鐘
            10,                # 冒號
            secs // 10,        # 十位秒
            secs % 10          # 個位秒
        ]
        
        # 繪製每個字符
        for i, digit_value in enumerate(digits):
            cache = self._time_buffer[str(i)]
            
            # 只在數字改變時更新緩衝
            if cache['status'] != digit_value:
                # 從預載緩存中獲取數字圖像
                if digit_value in self._digit_cache:
                    cached_digit = self._digit_cache[digit_value]
                    
                    # 複製到位置緩衝
                    cache['buff'].blit(cached_digit['buff'], 0, 0)
                    cache['status'] = digit_value
                else:
                    print(f"[WARN] Digit {digit_value} not in cache!")
            
            # 繪製到時間緩衝區
            self.time_buffer.blit(cache['buff'], i * digit_width, 0)
        
        return self.time_buffer
     
    
    def get_resource_info(self, resource_name):
        """
        獲取資源的配置信息
        Args:
            resource_name: 資源名稱
        Returns:
            配置字典或None
        """
        if resource_name in self.resources:
            return self.resources[resource_name].config.copy()
        return None
    
    def get_all_resources(self):
        """獲取所有資源名稱列表"""
        return list(self.resources.keys())
    
    def reset_resource(self, resource_name):
        """重置資源到第一幀"""
        if resource_name in self.resources:
            self.resources[resource_name].reset()
            print(f"✓ Reset resource: {resource_name}")
    
    def cleanup(self):
        """清理所有資源"""
        for name, resource in self.resources.items():
            resource.cleanup()
            print(f"✓ Cleaned up: {name}")
        
        self.resources = {}
        print("✓ All resources cleaned up")










import time,machine

from TFTController import *
from JpegBufferController import *


class CountdownTimer:
    def __init__(self):
        self.total_time = 0  # 單位：秒
        self.current_time = 0
        self.is_running = False
        self.update_interval = 1000  # 單位：毫秒，預設1秒
        self.time_update_gen = []  # 生成器對象列表
        self.time_update_fun = []  # 函數對象列表
        self.end_gen = []          # 生成器對象列表
        self.end_fun = []          # 函數對象列表
        self.timer = None
        self.update_triggered = False
        self.end_triggered = False
        
        self.start_time = 0
        self.temp_time = 0

    def set_time(self, time):
        """設定計時時間（秒）"""
        self.total_time = time
        self.current_time = time  # 重置當前時間

    def get_current_time(self):
        """獲取當前剩餘時間（秒）"""
        return self.current_time

    def start(self):
        """開始計時"""
        if not self.is_running:
#             self.start_time = time.ticks_ms()
            self.is_running = True
            self.current_time = self.total_time  # 確保從設定時間開始
            # 初始化硬體定時器，使用虛擬定時器（-1）以節省硬體資源
            self.timer = machine.Timer(3)
            self.timer.init(period=self.update_interval, mode=machine.Timer.PERIODIC, callback=self._tick)

    def stop(self):
        """停止計時"""
        if self.is_running:
            self.is_running = False
            if self.timer:
                self.timer.deinit()
                self.timer = None

    def on_time_update(self, gen=None, fun=None):
        """添加時間更新事件的回調。參數為生成器列表或函數列表。"""
        if gen is not None:
            if isinstance(gen, list):
                self.time_update_gen.extend(gen)
            else:
                self.time_update_gen.append(gen)
        if fun is not None:
            if isinstance(fun, list):
                self.time_update_fun.extend(fun)
            else:
                self.time_update_fun.append(fun)

    def on_countdown_end(self, gen=None, fun=None):
        """添加計時結束事件的回調。參數為生成器列表或函數列表。"""
        if gen is not None:
            if isinstance(gen, list):
                self.end_gen.extend(gen)
            else:
                self.end_gen.append(gen)
        if fun is not None:
            if isinstance(fun, list):
                self.end_fun.extend(fun)
            else:
                self.end_fun.append(fun)

    def _tick(self, timer):
        """定時器中斷回調（每間隔呼叫一次）。保持簡潔以符合中斷要求。"""
        if self.is_running:
            self.current_time -= 1  # 減少當前時間（假設間隔為1秒）
            if self.current_time <= 0:
                self.current_time = 0
                self.end_triggered = True  # 標記計時結束
                self.is_running = False    # 停止計時
            else:
                self.update_triggered = True  # 標記時間更新

    def update(self):
        """處理待處理的回調事件。應在主循環中定期呼叫。"""
        # 處理時間更新事件
        
#         if self.is_running:
#             self.temp_time += time.ticks_diff( time.ticks_ms(),self.start_time)
#             self.start_time = time.ticks_ms()
#                 
#             if self.temp_time >= 1000:
#                 self.current_time -= 1
#                 self.temp_time -= 1000
#                 if self.current_time <= 0:
#                     self.current_time = 0
#                     self.end_triggered = True  # 標記計時結束
#                     self.is_running = False    # 停止計時
#                 else:
#                     self.update_triggered = True  # 標記時間更新

        if self.update_triggered:
            self.update_triggered = False
            current_time = self.current_time  # 獲取當前時間
            
            # 處理生成器回調：呼叫 send() 並傳遞當前時間
            to_remove_gen = []
            for i, gen in enumerate(self.time_update_gen):
                try:
                    gen.send(current_time)  # 傳遞當前時間給生成器
                except StopIteration:
                    to_remove_gen.append(i)  # 標記完成生成器
                except Exception as e:
                    print("生成器錯誤:", e)
                    to_remove_gen.append(i)  # 錯誤時移除生成器
            
            # 從後往前移除生成器，避免索引偏移
            for i in sorted(to_remove_gen, reverse=True):
                del self.time_update_gen[i]
            
            # 處理函數回調，傳遞當前時間
            for fun in self.time_update_fun:
                try:
                    fun(current_time)  # 呼叫函數並傳遞當前時間
                except Exception as e:
                    print("函數回調錯誤:", e)

        # 處理計時結束事件
        if self.end_triggered:
            self.end_triggered = False
            current_time = self.current_time  # 這裡應該是0
            
            # 處理生成器回調
            to_remove_gen = []
            for i, gen in enumerate(self.end_gen):
                try:
                    gen.send(current_time)  # 傳遞當前時間給生成器
                except StopIteration:
                    to_remove_gen.append(i)
                except Exception as e:
                    print("生成器錯誤:", e)
                    to_remove_gen.append(i)
            
            for i in sorted(to_remove_gen, reverse=True):
                del self.end_gen[i]
            
            # 處理函數回調，傳遞當前時間（0）
            for fun in self.end_fun:
                try:
                    fun(current_time)
                except Exception as e:
                    print("函數回調錯誤:", e)
            
            # 停止定時器
            self.stop()



class DisplayController:
    """主控制器類，管理LCD顯示和各種硬體交互"""
    def __init__(self, config, lcd, uart, encoder, encoder_button, buffer_mgr, timer,touch = None,reverse = False):
        # 硬體物件
        self.config = config
        self.lcd = lcd
        self.uart = uart
        self.encoder = encoder
        self.buffer_mgr = buffer_mgr
        self.timer = timer
        self.reverse = reverse
        # 按鈕處理器
        self.button_handler = ButtonController(encoder_button, self._on_button_event)
        if touch :
            self.touch_controller = TouchController(touch,touch_width=240, touch_height=320, rotation=3, callback=self._on_touche_event)
            self.touch_controller.add_button( 0, 0, 120, 48, callback=None, name="0")
            self.touch_controller.add_button( 0, 48, 120, 48, callback=None, name="1")
            self.touch_controller.add_button( 0, 96, 120, 48, callback=None, name="2")
            self.touch_controller.add_button( 0, 144, 120, 48, callback=None, name="3")
            self.touch_controller.add_button( 0, 192, 120, 48, callback=None, name="4")
        else:
            self.touch_controller = None
        # 狀態變數
        self.mode_count = 0
        self.last_mode_count = -1
        self.brightness_value = 1
        self.last_brightness_value = -1
        self.encoder_max = 0
        self.last_time = None
        self.frame_count = 0
        # 模式信息
        self.mod_info = None
        self.brightness_info = None
        # 初始化編碼器
        self.encoder.value(self.brightness_value)
        # 初始化顯示
        self._initialize_display()
        
        
    def _initialize_display(self):
        """初始化顯示背景和基本元素"""
        # 顯示背景
        bg_buf = self.buffer_mgr.get_background()
        if bg_buf:
            self.lcd.set_window(0, 0)
            self.lcd.write_data(bg_buf)
            
        self.brightness_info = self.buffer_mgr.get_resource_info('brightness')
        self.mod_info = self.buffer_mgr.get_resource_info('mod')
        self.loop_info = self.buffer_mgr.get_resource_info('loop')
        self.text_info = self.buffer_mgr.get_resource_info('text')
        
        self.encoder_max = self.brightness_info['depth']-1
        
        # 初始化時間顯示
        self.timer.start()
        self.last_time = self.timer.current_time
        self.time_buf = self.buffer_mgr.update_time_display(self.last_time)
        # 初始化模式顯示
        self._update_mode_display()
        # 初始化亮度顯示
        self._update_brightness_display()
    def _on_button_event(self, event_type):
        """處理按鈕事件"""
        if event_type == 'click':
            self._switch_mode()
            self._send_uart_update()
            print('click')
        elif event_type == 'double_click':
#             self._switch_mode()
#             self._send_uart_update('mode', self.mode_count)
  
#             _root_path = self.config['root_path']%self.config['patter']
#             root_path = f'/sd/{_root_path}/'
#             self.buffer_mgr.reinitialize(root_path)
            # 雙擊事件處理
            print("Double click detected")
            # 可以添加其他功能，比如重置設定等
        elif event_type == 'long_press':
            # 長按事件處理
            print("Long press detected")
            # 可以添加其他功能，比如進入設定模式等
    def _on_touche_event(self, ev_type, ev_value):
        """處理按鈕事件"""
        if ev_type == 'touche':
            self._switch_mode(ev_value)
            self._send_uart_update()
#             print('click')
        elif ev_type == 'brightness':
            self._handle_encoder(ev_value)
  
#             print("brightness",ev_value)
            # 可以添加其他功能，比如重置設定等
        elif ev_type == 'wifi':
            # 長按事件處理
            print("wifi")
            # 可以添加其他功能，比如進入設定模式等
    def _switch_mode(self,mode=None):
        """切換模式"""
        print('mode',mode)
        if mode != None:
            self.mode_count = mode % self.mod_info['depth']
              
        else:
            if self.mod_info:
                self.mode_count = (self.mode_count + 1) % self.mod_info['depth']
            else:
                self.mode_count = (self.mode_count + 1) % 3  # 默認3個模式
        if self.config['offline']:
            self.timer.set_time(self.buffer_mgr.counter_time[self.mode_count])
#         print(f"Mode switched to: {self.mode_count}")
    def _update_mode_display(self):
        """更新模式顯示"""
        mod_buf = self.buffer_mgr.jump_to_frame('mod', self.mode_count)
        if mod_buf:
            
            x, y = self.mod_info['x'], self.mod_info['y']
            if self.reverse :
                w, h =  self.mod_info['height'] , self.mod_info['width']
            else:
                w, h = self.mod_info['width'], self.mod_info['height']
            self.lcd.set_window(x, y, x + w - 1, y + h - 1)
            self.lcd.write_data(mod_buf)
    def _update_brightness_display(self):
        """更新亮度顯示"""
        brightness_buf = self.buffer_mgr.jump_to_frame('brightness', self.brightness_value)
        if brightness_buf:
            x, y = self.brightness_info['x'], self.brightness_info['y']
            if self.reverse :
                w, h =  self.brightness_info['height'] , self.brightness_info['width']
            else:
                w, h = self.brightness_info['width'], self.brightness_info['height']
            self.lcd.set_window(x, y, x + w - 1, y + h - 1)
            self.lcd.write_data(brightness_buf)
    def _update_time_display(self):
        """更新時間顯示"""
        new_time = self.timer.current_time
#         print(new_time)
        if self.config['offline'] and new_time == 0:
            self._switch_mode()
            self.timer.start()
        if self.last_time != new_time:
#             print('new_time:', new_time)
            self.last_time = new_time
            self.time_buf = self.buffer_mgr.update_time_display(new_time)
            return None
        return None
    def _update_loop_animation(self, time_buf):
        """更新循環動畫"""
        loop_buf = self.buffer_mgr.get_next_frame('loop')
        if loop_buf:
            
            if time_buf:
                text_x, text_y = self.text_info['x'], self.text_info['y']
                loop_buf.blit(time_buf, text_x, text_y,0)
            x, y = self.loop_info['x'], self.loop_info['y']
            if self.reverse :
                w, h =  self.loop_info['height'] , self.loop_info['width']
            else:
                w, h = self.loop_info['width'], self.loop_info['height']
            self.lcd.set_window(x, y, x + w - 1, y + h - 1)
            self.lcd.write_data(loop_buf)
    def _handle_encoder(self,in_data=None):
        """處理編碼器輸入"""
        encoder_value = self.encoder.value()
        if in_data !=None:
            encoder_value = encoder_value + in_data
            self.encoder.value(encoder_value)
  
        # 限制編碼器範圍
        if encoder_value > self.encoder_max:
            encoder_value = self.encoder_max
            self.encoder.value(self.encoder_max)
        elif encoder_value < 0:
            encoder_value = 0
            self.encoder.value(0)
        # 檢查亮度是否改變
        if self.brightness_value != encoder_value:
            self.brightness_value = encoder_value
            self._send_uart_update()
    def _send_uart_update(self):
        """發送UART更新信號"""
        if self.uart:
            _data = bytearray([0xB4,self.mode_count,self.brightness_value,self.last_time,0xFF])
            try:
                self.uart.write(_data)
            except Exception as e:
                print(f"UART send error: {e}")
    def _handle_uart_receive(self):
        """處理UART接收的數據 - 使用二進制格式"""
        if self.uart and self.uart.any():
            try:
                # 讀取所有可用字節
                data = self.uart.read()
#                 print(data)
                # 查找有效的數據包 (起始標誌0xB4，結束標誌0xFF)
                start_idx = -1
                for i in range(len(data)):
                    if data[i]==0xB4 and i + 4 < len(data) and data[i+4]==0xFF:
                        start_idx = i
                        break
  
                if start_idx != -1:
                    # 提取數據包內容
                    mode = data[start_idx + 1]
                    brightness = data[start_idx + 2] /190
                    brightness = int(brightness*36)
                    time_remaining = data[start_idx + 3]
  
                    self._process_uart_command(mode, brightness, time_remaining)
            except Exception as e:
                print(f"UART receive error: {e}")
  
    def _process_uart_command(self, mode, brightness, time_remaining):
        """處理UART命令 - 直接使用二進制值"""
        # 更新模式
        if 0 <= mode <= 10:  # 常規模式
            self.mode_count = mode
            print(f"Mode changed to: {mode}")
        elif mode == 0x77:   # 程式錯誤模式
            print("Program error mode activated")
            # 處理錯誤模式的邏輯
        elif mode == 0x47:   # Wi-Fi模式
            print("Wi-Fi mode activated")
            # 處理Wi-Fi模式的邏輯
        # 更新亮度
        self.encoder.value(brightness)
        self.brightness_value = brightness
        # 更新剩餘時間
        if time_remaining >= 0:
#             self.timer.current_time = time_remaining
            self.timer.stop()
            self.timer.set_time(time_remaining)
            self.timer.start()
            print(f"Time remaining updated to: {time_remaining} seconds")
  
    def update(self,debug = False ):
        """主更新函數，在主循環中調用"""
        start_time = time.ticks_ms()
        # 更新按鈕狀態
        self.button_handler.update()
        self.button_handler.check_single_click()
        if self.touch_controller:
            self.touch_controller.update()
        # 處理編碼器
        self._handle_encoder()
        # 處理UART接收
        self._handle_uart_receive()
        # 更新計時器
        self.timer.update()
        # 更新時間顯示
        self._update_time_display()
#         self.time_buf = self._update_time_display()
        # 更新循環動畫
        self._update_loop_animation(self.time_buf)
        # 更新模式顯示（如果改變）
        if self.last_mode_count != self.mode_count:
            self.last_mode_count = self.mode_count
            self._update_mode_display()
        # 更新亮度顯示（如果改變）
        if self.last_brightness_value != self.brightness_value:
            self.last_brightness_value = self.brightness_value
            self._update_brightness_display()
#         self.frame_count += 1
        if debug :
            # 計算運行時間並控制幀率
            run_time = time.ticks_diff(time.ticks_ms(), start_time)
            print('run_time:', run_time)
            if run_time <= 20:
                time.sleep_ms(20 - run_time)
            return run_time
        else:
            return 0

