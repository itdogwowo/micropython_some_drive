<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PXLD v3 å‹•ç•«æ’­æ”¾å™¨ - å„ªåŒ–ç‰ˆ</title>
    <style>
        /* ... ä¿æŒä¹‹å‰çš„æ‰€æœ‰ CSS ... */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #2d3748;
        }
        
        h1 {
            color: #63b3ed;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            color: #a0aec0;
            font-size: 1.1rem;
        }
        
        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: rgba(45, 55, 72, 0.7);
            border-radius: 12px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid #4a5568;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .visualization {
            background: rgba(26, 32, 44, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #4a5568;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-height: 700px;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: auto;
            margin-bottom: 20px;
            min-height: 500px;
            position: relative;
        }
        
        canvas {
            display: block;
            background: #0f1419;
            border-radius: 4px;
            image-rendering: pixelated;
            cursor: crosshair;
        }
        
        .file-section {
            margin-bottom: 25px;
        }
        
        .file-section h3 {
            margin-bottom: 12px;
            color: #cbd5e0;
            font-size: 1rem;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2d3748;
            border: 2px dashed #4a5568;
            border-radius: 8px;
            color: #cbd5e0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="file"]:hover {
            border-color: #63b3ed;
            background: #374151;
        }
        
        button {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 8px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
            background: linear-gradient(135deg, #3182ce 0%, #2c5282 100%);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .playback-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .playback-controls button {
            padding: 10px;
            margin-top: 0;
            font-size: 0.9rem;
        }
        
        .info-panel {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 18px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            color: #cbd5e0;
            font-size: 0.95rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #374151;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #374151;
            font-size: 0.9rem;
        }
        
        .info-item:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }
        
        .info-label {
            color: #a0aec0;
            font-weight: 500;
        }
        
        .info-value {
            color: #63b3ed;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .slider-container {
            margin: 18px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #cbd5e0;
            font-size: 0.9rem;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #4a5568;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #63b3ed;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .slave-selector {
            margin: 18px 0;
        }
        
        .slave-selector h3 {
            margin-bottom: 10px;
            color: #cbd5e0;
            font-size: 0.95rem;
        }
        
        select {
            width: 100%;
            padding: 10px;
            background: #2d3748;
            color: #cbd5e0;
            border: 1px solid #4a5568;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        select:hover {
            border-color: #63b3ed;
        }
        
        .led-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 12px;
        }
        
        .stat-card {
            background: rgba(45, 55, 72, 0.6);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #4299e1;
        }
        
        .stat-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: #63b3ed;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #a0aec0;
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(23, 25, 35, 0.98);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #2d3748;
            backdrop-filter: blur(10px);
            z-index: 100;
            font-size: 0.9rem;
        }
        
        .frame-info {
            display: flex;
            gap: 20px;
        }
        
        .progress-bar {
            flex: 1;
            height: 6px;
            background: #4a5568;
            border-radius: 3px;
            overflow: hidden;
            margin: 0 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4299e1, #63b3ed);
            width: 0%;
            transition: width 0.2s ease;
        }
        
        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 20px;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid #4a5568;
            border-top-color: #4299e1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-text {
            color: #cbd5e0;
            font-size: 1.1rem;
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: #4a5568;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-progress-fill {
            height: 100%;
            background: #4299e1;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .warning {
            background: rgba(234, 179, 8, 0.1);
            border-left: 4px solid #eab308;
            padding: 10px;
            border-radius: 4px;
            margin-top: 12px;
            font-size: 0.85rem;
        }
        
        .error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid #ef4444;
            padding: 10px;
            border-radius: 4px;
            margin-top: 12px;
            font-size: 0.85rem;
        }
        
        .success {
            background: rgba(34, 197, 94, 0.1);
            border-left: 4px solid #22c55e;
            padding: 10px;
            border-radius: 4px;
            margin-top: 12px;
            font-size: 0.85rem;
        }
        
        .led-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 5px;
        }
        
        .badge-ws2812b {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            border: 1px solid #8b5cf6;
        }
        
        .badge-apa102c {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            border: 1px solid #22c55e;
        }
        
        .badge-standard {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid #f59e0b;
        }
        
        .badge-unknown {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
            border: 1px solid #6b7280;
        }
        
        .led-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 200;
            display: none;
            border: 1px solid #4a5568;
        }
        
        .crc-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .crc-pass {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
            border: 1px solid #22c55e;
        }
        
        .crc-fail {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: 1px solid #ef4444;
        }
        
        .crc-none {
            background: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
            border: 1px solid #6b7280;
        }
        
        .performance-info {
            background: rgba(45, 55, 72, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #a0aec0;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">æ­£åœ¨è¼‰å…¥å’Œè§£ææª”æ¡ˆ...</div>
        <div class="loading-progress">
            <div class="loading-progress-fill" id="loadingProgress"></div>
        </div>
    </div>
    
    <div class="container">
        <header>
            <h1>ğŸ¨ PXLD å‹•ç•«æ’­æ”¾å™¨ <span class="version-badge">v3 å„ªåŒ–ç‰ˆ</span></h1>
            <p class="subtitle">é«˜é€Ÿè¼‰å…¥ â€¢ RGBW æ ¼å¼ â€¢ CRC32 é©—è­‰ â€¢ æ™ºæ…§å‹ç´¢å¼•</p>
        </header>
        
        <div class="main-content">
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <!-- æª”æ¡ˆè¼‰å…¥ -->
                <div class="file-section">
                    <h3>ğŸ“ è¼‰å…¥ PXLD v3 æª”æ¡ˆ</h3>
                    <input type="file" id="fileInput" accept=".pxld">
                    <button id="loadBtn" onclick="loadFile()">
                        ğŸš€ è¼‰å…¥ä¸¦è§£ææª”æ¡ˆ
                    </button>
                    <div class="warning">
                        <strong>âš ï¸ æ³¨æ„ï¼š</strong> åƒ…æ”¯æ´ PXLD v3 æ ¼å¼ã€‚å–®è‰² LED ä½¿ç”¨ W é€šé“ (ç¬¬4å­—ç¯€)ã€‚
                    </div>
                </div>
                
                <!-- Slave é¸æ“‡å™¨ -->
                <div class="slave-selector">
                    <h3>ğŸ¯ Slave é¸æ“‡</h3>
                    <select id="slaveSelect" onchange="changeSlaveDisplay(this.value)" disabled>
                        <option value="-1">å…¨éƒ¨é¡¯ç¤º</option>
                    </select>
                    <div id="slaveInfo" class="info-panel" style="display: none;">
                        <h3>Slave è©³ç´°è³‡è¨Š</h3>
                        <div class="info-item">
                            <span class="info-label">Slave ID</span>
                            <span class="info-value" id="currentSlaveId">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">é€šé“ç¯„åœ</span>
                            <span class="info-value" id="slaveChannels">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">LED æ•¸é‡</span>
                            <span class="info-value" id="slavePixelCount">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">æ•¸æ“šé•·åº¦</span>
                            <span class="info-value" id="slaveDataLength">-</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">LED é¡å‹</span>
                            <span class="info-value" id="slaveLedTypes">-</span>
                        </div>
                    </div>
                </div>
                
                <!-- æ’­æ”¾æ§åˆ¶ -->
                <div class="playback-controls">
                    <button id="playBtn" onclick="togglePlay()" disabled>
                        â–¶ï¸ æ’­æ”¾
                    </button>
                    <button id="pauseBtn" onclick="pausePlayback()" disabled>
                        â¸ï¸ æš«åœ
                    </button>
                    <button id="stopBtn" onclick="stopPlayback()" disabled>
                        â¹ï¸ åœæ­¢
                    </button>
                </div>
                
                <!-- é€Ÿåº¦æ§åˆ¶ -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>âš¡ æ’­æ”¾é€Ÿåº¦</span>
                        <span id="speedValue">1.0x</span>
                    </div>
                    <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1" oninput="updateSpeed(this.value)">
                </div>
                
                <!-- å½±æ ¼æ§åˆ¶ -->
                <div class="slider-container">
                    <div class="slider-label">
                        <span>ğŸï¸ å½±æ ¼æ§åˆ¶</span>
                        <span id="frameValue">0 / 0</span>
                    </div>
                    <input type="range" id="frameSlider" min="0" max="0" value="0" oninput="seekFrame(parseInt(this.value))" disabled>
                </div>
                
                <!-- æª”æ¡ˆè³‡è¨Š -->
                <div class="info-panel" id="fileInfo" style="display: none;">
                    <h3>ğŸ“Š æª”æ¡ˆè³‡è¨Š</h3>
                    <div class="info-item">
                        <span class="info-label">æª”æ¡ˆæ ¼å¼</span>
                        <span class="info-value" id="magic">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ç‰ˆæœ¬</span>
                        <span class="info-value" id="version">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">FPS</span>
                        <span class="info-value" id="fps">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Slave æ•¸é‡</span>
                        <span class="info-value" id="slaves">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ç¸½å½±æ ¼æ•¸</span>
                        <span class="info-value" id="totalFrames">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">UDP åŸ </span>
                        <span class="info-value" id="udpPort">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">CRC32 é©—è­‰</span>
                        <span class="info-value" id="crcStatus">-</span>
                    </div>
                    
                    <div class="led-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="totalChannels">0</div>
                            <div class="stat-label">ç¸½é€šé“æ•¸</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalPixels">0</div>
                            <div class="stat-label">ç¸½ LED æ•¸</div>
                        </div>
                    </div>
                    
                    <div class="performance-info">
                        <div>âš¡ è¼‰å…¥æ™‚é–“: <span id="loadTime">-</span></div>
                        <div>ğŸ“¦ æª”æ¡ˆå¤§å°: <span id="fileSize">-</span></div>
                    </div>
                </div>
            </div>
            
            <!-- è¦–è¦ºåŒ–å€åŸŸ -->
            <div class="visualization">
                <h3>ğŸ–¼ï¸ LED è¦–è¦ºåŒ–é¡¯ç¤º</h3>
                <div class="canvas-container">
                    <canvas id="ledCanvas"></canvas>
                    <div class="led-tooltip" id="ledTooltip"></div>
                </div>
                <div class="info-panel">
                    <div class="info-item">
                        <span class="info-label">ç•¶å‰å½±æ ¼</span>
                        <span class="info-value" id="currentFrame">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">æ™‚é–“æˆ³</span>
                        <span class="info-value" id="timestamp">0.00 ms</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">æ’­æ”¾ç‹€æ…‹</span>
                        <span class="info-value" id="playStatus">æœªè¼‰å…¥</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">é¡¯ç¤ºæ¨¡å¼</span>
                        <span class="info-value" id="displayMode">å…¨éƒ¨</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ç‹€æ…‹åˆ— -->
    <div class="status-bar">
        <div class="frame-info">
            <div>å½±æ ¼: <span id="statusFrame">0</span>/<span id="statusTotalFrames">0</span></div>
            <div>æ™‚é–“: <span id="statusTime">0.0s</span></div>
            <div>å¯¦éš› FPS: <span id="statusFPS">0</span></div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div>é »å¯¬: <span id="statusBandwidth">0.00</span> Mbps</div>
    </div>

    <script>
        // ==================== LED é¡å‹é…ç½® ====================
        const LED_CONFIGURATIONS = {
            0: [ // Slave 0 é…ç½®
                {
                    type: 'APA102C',
                    label: 'broken_mirror_rgb',
                    description: 'ç ´é¡ RGB',
                    count: 190,
                    channels_per_pixel: 3,
                    data_offset: 0,
                    data_length: 760  // 190 * 4 bytes (RGBW)
                },
                {
                    type: 'APA102C',
                    label: 'smoke_rgb',
                    description: 'ç…™é›² RGB',
                    count: 100,
                    channels_per_pixel: 3,
                    data_offset: 760,
                    data_length: 400  // 100 * 4 bytes
                },
                {
                    type: 'WS2812B',
                    label: 'gundam_rgb',
                    description: 'é«˜é” RGB',
                    count: 30,
                    channels_per_pixel: 3,
                    data_offset: 1160,
                    data_length: 120  // 30 * 4 bytes
                },
                {
                    type: 'STANDARD_LED',
                    label: 'gundam_led',
                    description: 'é«˜é”å–®è‰² LED',
                    count: 16,
                    channels_per_pixel: 1,
                    data_offset: 1280,
                    data_length: 64   // 16 * 4 bytes (Wé€šé“æœ‰æ•ˆ)
                }
            ]
        };

        // ==================== PXLD v3 è§£ç¢¼å™¨ - å„ªåŒ–ç‰ˆ ====================
        class PXLDv3Decoder {
            constructor() {
                // çµæ§‹å¤§å°å¸¸æ•¸
                this.FILE_HEADER_SIZE = 64;
                this.FRAME_HEADER_SIZE = 32;
                this.SLAVE_ENTRY_SIZE = 24;
                this.BYTES_PER_LED = 4;  // å›ºå®šæ¯å€‹ LED 4 å­—ç¯€ (RGBW)
                
                // è§£æå¾Œçš„æ•¸æ“š
                this.fileHeader = null;
                this.frameOffsets = [];  // å¹€ç´¢å¼•è¡¨
                this.arrayBuffer = null;
                this.dataView = null;
                
                // ç‹€æ…‹
                this.currentFrameIndex = 0;
                this.slaveConfigs = LED_CONFIGURATIONS;
                
                // æ•ˆèƒ½ç›£æ§
                this.loadStartTime = 0;
                this.loadEndTime = 0;
            }
            
            /**
             * è§£ææª”æ¡ˆæ¨™é ­ (64 bytes)
             */
            parseFileHeader(dataView) {
                // 1. é©—è­‰é­”è¡“æ•¸å­—
                let magic = '';
                for (let i = 0; i < 4; i++) {
                    magic += String.fromCharCode(dataView.getUint8(i));
                }
                
                if (magic !== 'PXLD') {
                    throw new Error(`ç„¡æ•ˆçš„ PXLD æª”æ¡ˆï¼Œé æœŸ 'PXLD' ä½†å¾—åˆ° '${magic}'`);
                }
                
                // 2. é©—è­‰ç‰ˆæœ¬
                const majorVersion = dataView.getUint8(4);
                const minorVersion = dataView.getUint8(5);
                
                if (majorVersion !== 3) {
                    throw new Error(`æ­¤è§£ç¢¼å™¨åƒ…æ”¯æ´ v3 æ ¼å¼ï¼Œæª”æ¡ˆç‰ˆæœ¬ç‚º ${majorVersion}.${minorVersion}`);
                }
                
                // 3. è§£ææ¨™é ­æ¬„ä½ (little-endian)
                this.fileHeader = {
                    magic: magic,
                    majorVersion: majorVersion,
                    minorVersion: minorVersion,
                    version: `${majorVersion}.${minorVersion}`,
                    fps: dataView.getUint8(6),
                    totalSlaves: dataView.getUint16(7, true),       // u16 little-endian
                    totalFrames: dataView.getUint32(9, true),       // u32
                    totalPixels: dataView.getUint32(13, true),      // u32
                    frameHeaderSize: dataView.getUint16(17, true),  // u16
                    slaveEntrySize: dataView.getUint16(19, true),   // u16
                    udpPort: dataView.getUint16(21, true),          // u16
                    fileCrc32: dataView.getUint32(23, true),        // u32
                    checksumType: dataView.getUint8(27)
                };
                
                // 4. è¨ˆç®—ç¸½é€šé“æ•¸
                this.fileHeader.totalChannels = this.fileHeader.totalPixels * this.BYTES_PER_LED;
                
                console.log('âœ… æª”æ¡ˆæ¨™é ­è§£æå®Œæˆ:', this.fileHeader);
                return this.fileHeader;
            }
            
            /**
             * é©—è­‰æª”æ¡ˆ CRC32 æ ¡é©—
             */
            verifyCRC32(dataView) {
                if (this.fileHeader.checksumType === 0) {
                    console.warn('âš ï¸  æª”æ¡ˆæœªä½¿ç”¨ CRC32 æ ¡é©—');
                    return true;
                }
                
                const declaredCrc32 = this.fileHeader.fileCrc32;
                
                // CRC32 è¨ˆç®—å¾ offset 27 é–‹å§‹
                const crcData = new Uint8Array(dataView.buffer, 27);
                const calculatedCrc32 = this.crc32(crcData);
                
                const passed = declaredCrc32 === calculatedCrc32;
                
                if (passed) {
                    console.log(`âœ… CRC32 æ ¡é©—é€šé: ${calculatedCrc32.toString(16).toUpperCase().padStart(8, '0')}`);
                } else {
                    console.error(`âŒ CRC32 æ ¡é©—å¤±æ•—!`);
                    console.error(`  æª”æ¡ˆè²æ˜: ${declaredCrc32.toString(16).toUpperCase().padStart(8, '0')}`);
                    console.error(`  å¯¦éš›è¨ˆç®—: ${calculatedCrc32.toString(16).toUpperCase().padStart(8, '0')}`);
                    throw new Error('CRC32 æ ¡é©—å¤±æ•—ï¼Œæª”æ¡ˆå¯èƒ½å·²æå£');
                }
                
                return passed;
            }
            
            /**
             * CRC32 è¨ˆç®— (æ¨™æº–ç®—æ³•)
             */
            crc32(data) {
                let crc = 0xFFFFFFFF;
                
                for (let i = 0; i < data.length; i++) {
                    crc ^= data[i];
                    for (let j = 0; j < 8; j++) {
                        crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));
                    }
                }
                
                return (crc ^ 0xFFFFFFFF) >>> 0;
            }
            
            /**
             * ğŸš€ å„ªåŒ–ç‰ˆï¼šå¿«é€Ÿå»ºç«‹å¹€ç´¢å¼•è¡¨
             * ç­–ç•¥ï¼š
             * 1. å‡è¨­æ‰€æœ‰å¹€å¤§å°ç›¸åŒï¼ˆå¤§éƒ¨åˆ†æƒ…æ³æˆç«‹ï¼‰
             * 2. åªè®€å–å‰å¹¾å¹€ä¾†è¨ˆç®—å¹³å‡å¤§å°
             * 3. ä½¿ç”¨è¨ˆç®—çš„å¤§å°å¿«é€Ÿå»ºç«‹ç´¢å¼•
             * 4. å»¶é²é©—è­‰ï¼šæ’­æ”¾æ™‚æ‰é©—è­‰å¯¦éš›åç§»
             */
            buildFrameIndexFast(dataView) {
                console.log(`ğŸš€ é–‹å§‹å¿«é€Ÿå»ºç«‹å¹€ç´¢å¼• (å…± ${this.fileHeader.totalFrames} å¹€)...`);
                const startTime = performance.now();
                
                this.frameOffsets = [];
                
                // ç­–ç•¥1: è®€å–å‰ 10 å¹€ï¼ˆæˆ–ç¸½æ•¸çš„ 1%ï¼‰ä¾†ä¼°ç®—å¹€å¤§å°
                const sampleSize = Math.min(10, Math.max(1, Math.floor(this.fileHeader.totalFrames * 0.01)));
                const frameSizes = [];
                let currentOffset = this.FILE_HEADER_SIZE;
                
                for (let i = 0; i < sampleSize; i++) {
                    this.frameOffsets.push(currentOffset);
                    
                    // è®€å–å¹€æ¨™é ­
                    const slaveTableSize = dataView.getUint32(currentOffset + 8, true);
                    const pixelDataSize = dataView.getUint32(currentOffset + 12, true);
                    const frameSize = this.FRAME_HEADER_SIZE + slaveTableSize + pixelDataSize;
                    
                    frameSizes.push(frameSize);
                    currentOffset += frameSize;
                }
                
                // è¨ˆç®—å¹³å‡å¹€å¤§å°
                const avgFrameSize = Math.floor(frameSizes.reduce((a, b) => a + b, 0) / frameSizes.length);
                console.log(`  æ¡æ¨£ ${sampleSize} å¹€ï¼Œå¹³å‡å¤§å°: ${avgFrameSize.toLocaleString()} bytes`);
                
                // ç­–ç•¥2: ä½¿ç”¨å¹³å‡å¤§å°å¿«é€Ÿè¨ˆç®—å‰©é¤˜å¹€çš„åç§»
                for (let i = sampleSize; i < this.fileHeader.totalFrames; i++) {
                    currentOffset = this.FILE_HEADER_SIZE + (i * avgFrameSize);
                    this.frameOffsets.push(currentOffset);
                }
                
                const endTime = performance.now();
                console.log(`âœ… å¿«é€Ÿç´¢å¼•å»ºç«‹å®Œæˆï¼Œè€—æ™‚: ${(endTime - startTime).toFixed(2)} ms`);
                console.log(`  é ä¼°æª”æ¡ˆå¤§å°: ${currentOffset.toLocaleString()} bytes`);
                
                // è¿”å›æ•ˆèƒ½æ•¸æ“š
                return {
                    indexBuildTime: endTime - startTime,
                    avgFrameSize: avgFrameSize,
                    estimatedFileSize: currentOffset
                };
            }
            
            /**
             * è§£ææ•´å€‹æª”æ¡ˆ - å„ªåŒ–ç‰ˆ
             */
            parseFile(arrayBuffer) {
                this.loadStartTime = performance.now();
                
                this.arrayBuffer = arrayBuffer;
                this.dataView = new DataView(arrayBuffer);
                
                // 1. è§£ææ¨™é ­
                this.parseFileHeader(this.dataView);
                
                // 2. é©—è­‰ CRC32
                this.verifyCRC32(this.dataView);
                
                // 3. ğŸš€ å¿«é€Ÿå»ºç«‹å¹€ç´¢å¼•
                const indexStats = this.buildFrameIndexFast(this.dataView);
                
                this.loadEndTime = performance.now();
                
                return {
                    header: this.fileHeader,
                    frameCount: this.frameOffsets.length,
                    fileSize: arrayBuffer.byteLength,
                    loadTime: this.loadEndTime - this.loadStartTime,
                    indexBuildTime: indexStats.indexBuildTime,
                    avgFrameSize: indexStats.avgFrameSize
                };
            }
            
            /**
             * è®€å–æŒ‡å®šå½±æ ¼çš„å®Œæ•´æ•¸æ“š - å„ªåŒ–ç‰ˆ
             * å¢åŠ å®¹éŒ¯æ©Ÿåˆ¶ï¼šå¦‚æœä¼°ç®—çš„åç§»ä¸æ­£ç¢ºï¼Œè‡ªå‹•ä¿®æ­£
             */
            readFrame(frameIndex) {
                if (frameIndex < 0 || frameIndex >= this.frameOffsets.length) {
                    throw new RangeError(`å¹€ç´¢å¼• ${frameIndex} è¶…å‡ºç¯„åœ (0-${this.frameOffsets.length - 1})`);
                }
                
                let offset = this.frameOffsets[frameIndex];
                
                // é©—è­‰å¹€ ID æ˜¯å¦æ­£ç¢ºï¼ˆå®¹éŒ¯æ©Ÿåˆ¶ï¼‰
                let frameId = this.dataView.getUint32(offset, true);
                
                // å¦‚æœå¹€ ID ä¸åŒ¹é…ï¼Œå˜—è©¦å‘å‰/å¾Œæœç´¢
                if (frameId !== frameIndex && frameIndex > 10) {
                    console.warn(`å¹€ ${frameIndex} åç§»å¯èƒ½ä¸æº–ç¢ºï¼Œå˜—è©¦ä¿®æ­£...`);
                    
                    // æœç´¢ç¯„åœï¼šå‰å¾Œ 10KB
                    const searchRange = 10240;
                    let found = false;
                    
                    for (let delta = -searchRange; delta <= searchRange; delta += 4) {
                        const testOffset = offset + delta;
                        if (testOffset < 0 || testOffset >= this.arrayBuffer.byteLength) continue;
                        
                        const testFrameId = this.dataView.getUint32(testOffset, true);
                        if (testFrameId === frameIndex) {
                            offset = testOffset;
                            this.frameOffsets[frameIndex] = offset;  // æ›´æ–°ç´¢å¼•
                            found = true;
                            console.log(`  âœ… æ‰¾åˆ°æ­£ç¢ºåç§»: ${testOffset}`);
                            break;
                        }
                    }
                    
                    if (!found) {
                        console.error(`  âŒ ç„¡æ³•æ‰¾åˆ°å¹€ ${frameIndex} çš„æ­£ç¢ºåç§»`);
                    }
                }
                
                let currentOffset = offset;
                
                // 1. è®€å–å¹€æ¨™é ­ (32 bytes)
                frameId = this.dataView.getUint32(currentOffset, true);
                const flags = this.dataView.getUint16(currentOffset + 4, true);
                const slaveTableSize = this.dataView.getUint32(currentOffset + 8, true);
                const pixelDataSize = this.dataView.getUint32(currentOffset + 12, true);
                
                const frameHeader = {
                    frameId: frameId,
                    flags: flags,
                    slaveTableSize: slaveTableSize,
                    pixelDataSize: pixelDataSize,
                    timestampMs: frameIndex * (1000 / this.fileHeader.fps)
                };
                
                currentOffset += this.FRAME_HEADER_SIZE;
                
                // 2. è®€å– Slave æ¢ç›®è¡¨
                const slaveEntries = [];
                for (let i = 0; i < this.fileHeader.totalSlaves; i++) {
                    const slaveId = this.dataView.getUint8(currentOffset);
                    const slaveFlags = this.dataView.getUint8(currentOffset + 1);
                    const channelStart = this.dataView.getUint16(currentOffset + 2, true);
                    const channelCount = this.dataView.getUint16(currentOffset + 4, true);
                    const pixelCount = this.dataView.getUint16(currentOffset + 6, true);
                    const dataOffset = this.dataView.getUint32(currentOffset + 8, true);
                    const dataLength = this.dataView.getUint32(currentOffset + 12, true);
                    
                    slaveEntries.push({
                        slaveId: slaveId,
                        flags: slaveFlags,
                        channelStart: channelStart,
                        channelCount: channelCount,
                        pixelCount: pixelCount,
                        dataOffset: dataOffset,
                        dataLength: dataLength
                    });
                    
                    currentOffset += this.SLAVE_ENTRY_SIZE;
                }
                
                // 3. è®€å–åƒç´ æ•¸æ“š
                const pixelDataStart = offset + this.FRAME_HEADER_SIZE + slaveTableSize;
                const pixelData = new Uint8Array(this.arrayBuffer, pixelDataStart, pixelDataSize);
                
                return {
                    header: frameHeader,
                    slaves: slaveEntries,
                    pixelData: pixelData
                };
            }
            
            /**
             * æå–æŒ‡å®š Slave çš„ RGBW æ•¸æ“š
             */
            extractSlaveRGBWData(frameData, slaveId) {
                const slave = frameData.slaves.find(s => s.slaveId === slaveId);
                if (!slave) {
                    throw new Error(`æœªæ‰¾åˆ° Slave ID ${slaveId}`);
                }
                
                // æå–è©² Slave çš„åŸå§‹æ•¸æ“š
                const start = slave.dataOffset;
                const end = start + slave.dataLength;
                const rawData = frameData.pixelData.slice(start, end);
                
                // é©—è­‰æ•¸æ“šé•·åº¦
                const expectedLength = slave.pixelCount * this.BYTES_PER_LED;
                if (rawData.length !== expectedLength) {
                    console.warn(`Slave ${slaveId} æ•¸æ“šé•·åº¦ç•°å¸¸: é æœŸ ${expectedLength}, å¯¦éš› ${rawData.length}`);
                }
                
                // è§£æç‚º RGBW ç‰©ä»¶é™£åˆ—
                const leds = [];
                const config = this.slaveConfigs[slaveId];
                
                for (let i = 0; i < rawData.length; i += this.BYTES_PER_LED) {
                    if (i + this.BYTES_PER_LED > rawData.length) break;
                    
                    const r = rawData[i];
                    const g = rawData[i + 1];
                    const b = rawData[i + 2];
                    const w = rawData[i + 3];
                    
                    // åˆ¤æ–· LED é¡å‹
                    let ledType = 'UNKNOWN';
                    let label = 'unknown';
                    
                    if (config) {
                        let accumulated = 0;
                        for (const section of config) {
                            const ledIndex = i / this.BYTES_PER_LED;
                            if (ledIndex >= accumulated && ledIndex < accumulated + section.count) {
                                ledType = section.type;
                                label = section.label;
                                break;
                            }
                            accumulated += section.count;
                        }
                    }
                    
                    leds.push({
                        r: r,
                        g: g,
                        b: b,
                        w: w,
                        type: ledType,
                        label: label
                    });
                }
                
                return leds;
            }
            
            /**
             * ğŸ”§ ä¿®æ­£ï¼šå°‡ RGBW æ•¸æ“šè½‰æ›ç‚ºé¡¯ç¤ºç”¨ RGB é¡è‰²
             * é‡é»ï¼šå–®è‰² LED åªä½¿ç”¨ W é€šé“ï¼ˆç¬¬4å­—ç¯€ï¼‰
             */
            convertToLEDColors(rgbwData, ledType = null) {
                return rgbwData.map(led => {
                    const type = ledType || led.type;
                    
                    if (type === 'STANDARD_LED') {
                        // âœ… å–®è‰² LED: åªä½¿ç”¨ W é€šé“ (ç¬¬4å­—ç¯€)
                        // æ ¹æ“š v3 è¦ç¯„ï¼Œå–®è‰² LED çš„äº®åº¦å€¼å­˜å„²åœ¨ W é€šé“
                        const brightness = led.w;
                        return { 
                            r: brightness, 
                            g: brightness, 
                            b: brightness, 
                            type: type, 
                            label: led.label,
                            originalW: led.w  // ä¿ç•™åŸå§‹ W å€¼ä»¥ä¾›èª¿è©¦
                        };
                    } else if (type === 'WS2812B') {
                        // WS2812B: æ¨™æº– RGB é †åº (v3 æ ¼å¼å·²ç¶“è½‰æ›å¥½)
                        return { 
                            r: led.r, 
                            g: led.g, 
                            b: led.b, 
                            type: type, 
                            label: led.label 
                        };
                    } else {
                        // APA102C å’Œå…¶ä»–: æ¨™æº– RGB
                        return { 
                            r: led.r, 
                            g: led.g, 
                            b: led.b, 
                            type: type, 
                            label: led.label 
                        };
                    }
                });
            }
            
            /**
             * ç²å– Slave è³‡è¨Š
             */
            getSlaveInfo(slaveId) {
                if (!this.fileHeader) {
                    throw new Error('è«‹å…ˆè§£ææª”æ¡ˆ');
                }
                
                // è®€å–ç¬¬ä¸€å¹€ä»¥ç²å– Slave æ¢ç›®
                const frameData = this.readFrame(0);
                const slave = frameData.slaves.find(s => s.slaveId === slaveId);
                
                if (!slave) {
                    throw new Error(`æœªæ‰¾åˆ° Slave ID ${slaveId}`);
                }
                
                return {
                    slaveId: slave.slaveId,
                    channelStart: slave.channelStart,
                    channelEnd: slave.channelStart + slave.channelCount - 1,
                    channelCount: slave.channelCount,
                    pixelCount: slave.pixelCount,
                    dataLength: slave.dataLength,
                    bytesPerPixel: slave.dataLength / slave.pixelCount
                };
            }
        }

        // ==================== æ’­æ”¾å™¨ ====================
        class PXLDv3Player {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.decoder = new PXLDv3Decoder();
                
                // æ’­æ”¾ç‹€æ…‹
                this.isPlaying = false;
                this.currentFrameIndex = 0;
                this.totalFrames = 0;
                this.playbackSpeed = 1.0;
                this.animationId = null;
                this.lastFrameTime = 0;
                this.selectedSlaveId = -1;
                
                // æ•ˆèƒ½ç›£æ§
                this.frameTimes = [];
                this.actualFps = 0;
                
                // æ¸²æŸ“è¨­å®š
                this.ledSize = 10;
                this.ledSpacing = 3;
                
                // åˆå§‹åŒ–
                this.resizeCanvas();
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                const width = container.clientWidth - 40;
                const height = container.clientHeight - 40;
                
                this.canvas.width = Math.max(900, width);
                this.canvas.height = Math.max(450, height);
                
                if (this.totalFrames > 0) {
                    this.renderFrame();
                }
            }
            
            async loadFile(file) {
                showLoading(true, 'æ­£åœ¨è®€å–æª”æ¡ˆ...');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    showLoading(true, 'æ­£åœ¨è§£ææª”æ¡ˆ...');
                    
                    const fileInfo = this.decoder.parseFile(arrayBuffer);
                    this.totalFrames = fileInfo.frameCount;
                    
                    // æ›´æ–° UI
                    updateFileInfo(fileInfo.header, this.totalFrames, fileInfo);
                    this.updateSlaveSelector();
                    updateFrameSlider(this.totalFrames);
                    
                    // æ¸²æŸ“ç¬¬ä¸€å¹€
                    this.currentFrameIndex = 0;
                    this.renderFrame();
                    
                    enableControls(true);
                    
                    console.log('âœ… æª”æ¡ˆè¼‰å…¥æˆåŠŸ:', fileInfo);
                    console.log(`  ç¸½è¼‰å…¥æ™‚é–“: ${fileInfo.loadTime.toFixed(2)} ms`);
                    console.log(`  ç´¢å¼•å»ºç«‹æ™‚é–“: ${fileInfo.indexBuildTime.toFixed(2)} ms`);
                    
                } catch (error) {
                    showErrorMessage(`è¼‰å…¥æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
                    console.error('è§£æéŒ¯èª¤:', error);
                } finally {
                    showLoading(false);
                }
            }
            
            updateSlaveSelector() {
                const select = document.getElementById('slaveSelect');
                
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                for (let i = 0; i < this.decoder.fileHeader.totalSlaves; i++) {
                    try {
                        const slaveInfo = this.decoder.getSlaveInfo(i);
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `Slave ${i} (é€šé“ ${slaveInfo.channelStart}-${slaveInfo.channelEnd}, ${slaveInfo.pixelCount} LED)`;
                        select.appendChild(option);
                    } catch (error) {
                        console.warn(`ç„¡æ³•è®€å– Slave ${i} è³‡è¨Š:`, error);
                    }
                }
                
                select.disabled = false;
            }
            
            renderFrame(frameIdx = null) {
                if (frameIdx !== null) {
                    this.currentFrameIndex = Math.max(0, Math.min(frameIdx, this.totalFrames - 1));
                }
                
                if (!this.decoder.arrayBuffer || this.totalFrames === 0) {
                    this.renderPlaceholder();
                    return;
                }
                
                try {
                    const frameData = this.decoder.readFrame(this.currentFrameIndex);
                    
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    if (this.selectedSlaveId >= 0) {
                        this.renderSingleSlave(frameData, this.selectedSlaveId);
                    } else {
                        this.renderAllSlaves(frameData);
                    }
                    
                    updateFrameDisplay(this.currentFrameIndex, this.totalFrames, frameData.header.timestampMs);
                    updateStatusBar(this.currentFrameIndex, this.totalFrames, this.decoder.fileHeader.fps, this.actualFps);
                    
                } catch (error) {
                    console.error('æ¸²æŸ“éŒ¯èª¤:', error);
                    showErrorMessage(`æ¸²æŸ“å½±æ ¼ ${this.currentFrameIndex} æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
                }
            }
            
            renderSingleSlave(frameData, slaveId) {
                const rgbwData = this.decoder.extractSlaveRGBWData(frameData, slaveId);
                const leds = this.decoder.convertToLEDColors(rgbwData);
                
                const cols = 40;
                const ledWidth = Math.min(this.ledSize, (this.canvas.width - 60) / cols);
                const spacing = this.ledSpacing;
                
                let x = 30;
                let y = 30;
                let count = 0;
                let currentSection = null;
                
                const config = this.decoder.slaveConfigs[slaveId];
                
                for (let i = 0; i < leds.length; i++) {
                    const led = leds[i];
                    
                    // æª¢æŸ¥æ˜¯å¦é€²å…¥æ–°çš„ section
                    if (config) {
                        let accumulated = 0;
                        for (const section of config) {
                            if (i >= accumulated && i < accumulated + section.count) {
                                if (currentSection !== section.label) {
                                    if (currentSection !== null) {
                                        y += 15;
                                    }
                                    currentSection = section.label;
                                    
                                    // ç¹ªè£½ section æ¨™ç±¤
                                    this.ctx.fillStyle = '#cbd5e0';
                                    this.ctx.font = 'bold 13px monospace';
                                    this.ctx.fillText(`${section.description} (${section.type})`, x, y);
                                    y += 22;
                                    x = 30;
                                    count = 0;
                                }
                                break;
                            }
                            accumulated += section.count;
                        }
                    }
                    
                    // ç¹ªè£½ LED
                    this.ctx.fillStyle = `rgb(${led.r}, ${led.g}, ${led.b})`;
                    
                    if (led.type === 'STANDARD_LED') {
                        // å–®è‰² LED ä½¿ç”¨æ–¹å½¢
                        this.ctx.fillRect(x, y, ledWidth - 2, ledWidth - 2);
                        
                        // èª¿è©¦ï¼šé¡¯ç¤º W å€¼
                        if (led.originalW !== undefined && led.originalW > 0) {
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = '8px monospace';
                            this.ctx.fillText(led.originalW, x + 1, y + 8);
                        }
                    } else {
                        // RGB LED ä½¿ç”¨åœ“å½¢
                        this.ctx.beginPath();
                        this.ctx.arc(x + ledWidth/2, y + ledWidth/2, ledWidth/2 - 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // å…‰æšˆæ•ˆæœ
                    const brightness = led.r + led.g + led.b;
                    if (brightness > 30) {
                        this.ctx.shadowColor = `rgb(${led.r}, ${led.g}, ${led.b})`;
                        this.ctx.shadowBlur = led.type === 'STANDARD_LED' ? 5 : 12;
                        
                        if (led.type === 'STANDARD_LED') {
                            this.ctx.fillStyle = `rgb(${led.r}, ${led.g}, ${led.b})`;
                            this.ctx.fillRect(x, y, ledWidth - 2, ledWidth - 2);
                        } else {
                            this.ctx.fill();
                        }
                        
                        this.ctx.shadowBlur = 0;
                    }
                    
                    count++;
                    x += ledWidth + spacing;
                    
                    if (count % cols === 0) {
                        x = 30;
                        y += ledWidth + spacing;
                    }
                    
                    if (y + ledWidth > this.canvas.height - 60) {
                        break;
                    }
                }
                
                // é¡¯ç¤ºçµ±è¨ˆ
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                this.ctx.font = 'bold 14px monospace';
                this.ctx.fillText(`Slave ${slaveId} - é¡¯ç¤º ${leds.length} å€‹ LED`, 30, this.canvas.height - 35);
                
                if (config) {
                    this.ctx.font = '12px monospace';
                    let info = '';
                    for (const section of config) {
                        info += `${section.description}:${section.count} `;
                    }
                    this.ctx.fillText(info, 30, this.canvas.height - 18);
                }
                
                updateSlaveInfo(slaveId, this.decoder);
                updateDisplayMode(`Slave ${slaveId}`);
            }
            
            renderAllSlaves(frameData) {
                const cols = 100;
                const ledWidth = Math.min(6, (this.canvas.width - 60) / cols);
                const spacing = 2;
                
                let x = 30;
                let y = 30;
                let count = 0;
                let totalDisplayed = 0;
                
                const maxDisplay = 5000;
                
                for (const slave of frameData.slaves) {
                    if (totalDisplayed >= maxDisplay) break;
                    
                    try {
                        const rgbwData = this.decoder.extractSlaveRGBWData(frameData, slave.slaveId);
                        const leds = this.decoder.convertToLEDColors(rgbwData);
                        
                        for (const led of leds) {
                            if (totalDisplayed >= maxDisplay) break;
                            
                            this.ctx.fillStyle = `rgb(${led.r}, ${led.g}, ${led.b})`;
                            this.ctx.beginPath();
                            this.ctx.arc(x + ledWidth/2, y + ledWidth/2, ledWidth/2, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            const brightness = led.r + led.g + led.b;
                            if (brightness > 50) {
                                this.ctx.shadowColor = `rgb(${led.r}, ${led.g}, ${led.b})`;
                                this.ctx.shadowBlur = 8;
                                this.ctx.fill();
                                this.ctx.shadowBlur = 0;
                            }
                            
                            count++;
                            totalDisplayed++;
                            x += ledWidth + spacing;
                            
                            if (count % cols === 0) {
                                x = 30;
                                y += ledWidth + spacing;
                            }
                            
                            if (y + ledWidth > this.canvas.height - 50) {
                                break;
                            }
                        }
                    } catch (error) {
                        console.warn(`ç„¡æ³•æ¸²æŸ“ Slave ${slave.slaveId}:`, error);
                    }
                }
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.font = '13px monospace';
                this.ctx.fillText(
                    `é¡¯ç¤º ${totalDisplayed} å€‹ LED (ç¸½å…± ${this.decoder.fileHeader.totalPixels} å€‹)`,
                    30,
                    this.canvas.height - 25
                );
                
                updateDisplayMode('å…¨éƒ¨');
            }
            
            renderPlaceholder() {
                this.ctx.fillStyle = '#0f1419';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#4a5568';
                this.ctx.font = '22px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('è«‹è¼‰å…¥ PXLD v3 æª”æ¡ˆä»¥é–‹å§‹æ’­æ”¾', this.canvas.width/2, this.canvas.height/2);
                
                this.ctx.font = '15px sans-serif';
                this.ctx.fillStyle = '#718096';
                this.ctx.fillText('æ”¯æ´ RGBW æ ¼å¼ â€¢ å¿«é€Ÿè¼‰å…¥ â€¢ CRC32 é©—è­‰', this.canvas.width/2, this.canvas.height/2 + 35);
            }
            
            play() {
                if (this.isPlaying || this.totalFrames === 0) return;
                
                this.isPlaying = true;
                this.lastFrameTime = performance.now();
                
                const animate = (currentTime) => {
                    if (!this.isPlaying) return;
                    
                    const elapsed = currentTime - this.lastFrameTime;
                    const targetFrameTime = 1000 / (this.decoder.fileHeader.fps * this.playbackSpeed);
                    
                    if (elapsed >= targetFrameTime) {
                        this.currentFrameIndex = (this.currentFrameIndex + 1) % this.totalFrames;
                        this.renderFrame();
                        this.updateActualFPS(currentTime);
                        this.lastFrameTime = currentTime - (elapsed % targetFrameTime);
                    }
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                this.animationId = requestAnimationFrame(animate);
                updatePlaybackStatus('æ’­æ”¾ä¸­');
            }
            
            pause() {
                this.isPlaying = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                updatePlaybackStatus('å·²æš«åœ');
            }
            
            stop() {
                this.pause();
                this.currentFrameIndex = 0;
                this.renderFrame();
                updatePlaybackStatus('å·²åœæ­¢');
            }
            
            seek(frameIndex) {
                frameIndex = Math.max(0, Math.min(frameIndex, this.totalFrames - 1));
                this.currentFrameIndex = frameIndex;
                this.renderFrame();
            }
            
            setSpeed(speed) {
                this.playbackSpeed = speed;
            }
            
            setSelectedSlave(slaveId) {
                this.selectedSlaveId = parseInt(slaveId);
                this.renderFrame();
            }
            
            updateActualFPS(currentTime) {
                this.frameTimes.push(currentTime);
                
                while (this.frameTimes.length > 0 && currentTime - this.frameTimes[0] > 1000) {
                    this.frameTimes.shift();
                }
                
                this.actualFps = this.frameTimes.length;
            }
        }

        // ==================== å…¨åŸŸè®Šæ•¸å’Œå‡½æ•¸ ====================
        let player;
        
        document.addEventListener('DOMContentLoaded', () => {
            player = new PXLDv3Player('ledCanvas');
            initEventListeners();
        });
        
        function initEventListeners() {
            document.getElementById('fileInput').addEventListener('change', function(e) {
                if (this.files.length > 0) {
                    loadFile();
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (!player || player.totalFrames === 0) return;
                
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        togglePlay();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        player.seek(player.currentFrameIndex - 1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        player.seek(player.currentFrameIndex + 1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        player.seek(0);
                        break;
                    case 'End':
                        e.preventDefault();
                        player.seek(player.totalFrames - 1);
                        break;
                }
            });
        }
        
        async function loadFile() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput.files.length === 0) {
                alert('è«‹é¸æ“‡ä¸€å€‹æª”æ¡ˆ');
                return;
            }
            
            const file = fileInput.files[0];
            await player.loadFile(file);
        }
        
        function togglePlay() {
            if (!player) return;
            
            if (player.isPlaying) {
                player.pause();
                document.getElementById('playBtn').innerHTML = 'â–¶ï¸ æ’­æ”¾';
            } else {
                player.play();
                document.getElementById('playBtn').innerHTML = 'â¸ï¸ æš«åœ';
            }
        }
        
        function pausePlayback() {
            if (player) {
                player.pause();
                document.getElementById('playBtn').innerHTML = 'â–¶ï¸ æ’­æ”¾';
            }
        }
        
        function stopPlayback() {
            if (player) {
                player.stop();
                document.getElementById('playBtn').innerHTML = 'â–¶ï¸ æ’­æ”¾';
            }
        }
        
        function updateSpeed(speed) {
            if (player) {
                player.setSpeed(parseFloat(speed));
                document.getElementById('speedValue').textContent = speed + 'x';
            }
        }
        
        function seekFrame(frameIndex) {
            if (!player || player.totalFrames === 0) return;
            player.seek(frameIndex);
        }
        
        function changeSlaveDisplay(slaveId) {
            if (player) {
                player.setSelectedSlave(slaveId);
            }
        }
        
        function updateFileInfo(header, totalFrames, fileInfo) {
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('magic').textContent = header.magic;
            document.getElementById('version').textContent = header.version;
            document.getElementById('fps').textContent = header.fps;
            document.getElementById('slaves').textContent = header.totalSlaves;
            document.getElementById('totalFrames').textContent = totalFrames.toLocaleString();
            document.getElementById('totalChannels').textContent = header.totalChannels.toLocaleString();
            document.getElementById('totalPixels').textContent = header.totalPixels.toLocaleString();
            document.getElementById('udpPort').textContent = header.udpPort;
            
            // CRC32 ç‹€æ…‹
            const crcStatus = document.getElementById('crcStatus');
            if (header.checksumType === 0) {
                crcStatus.innerHTML = '<span class="crc-status crc-none">æœªä½¿ç”¨</span>';
            } else {
                crcStatus.innerHTML = '<span class="crc-status crc-pass">âœ“ é€šé</span>';
            }
            
            // æ•ˆèƒ½è³‡è¨Š
            document.getElementById('loadTime').textContent = `${fileInfo.loadTime.toFixed(2)} ms`;
            document.getElementById('fileSize').textContent = `${(fileInfo.fileSize / 1024 / 1024).toFixed(2)} MB`;
        }
        
        function updateFrameDisplay(currentFrame, totalFrames, timestampMs) {
            document.getElementById('currentFrame').textContent = (currentFrame + 1).toLocaleString();
            document.getElementById('timestamp').textContent = timestampMs.toFixed(2) + ' ms';
            document.getElementById('frameValue').textContent = `${currentFrame + 1} / ${totalFrames.toLocaleString()}`;
            
            const slider = document.getElementById('frameSlider');
            slider.value = currentFrame;
            
            document.getElementById('statusFrame').textContent = (currentFrame + 1).toLocaleString();
            document.getElementById('statusTotalFrames').textContent = totalFrames.toLocaleString();
            
            const progress = totalFrames > 0 ? ((currentFrame + 1) / totalFrames) * 100 : 0;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }
        
        function updateFrameSlider(totalFrames) {
            const slider = document.getElementById('frameSlider');
            slider.disabled = totalFrames === 0;
            slider.max = totalFrames > 0 ? totalFrames - 1 : 0;
        }
        
        function updateStatusBar(currentFrame, totalFrames, fps, actualFps) {
            const timeInSeconds = (currentFrame + 1) / fps;
            document.getElementById('statusTime').textContent = timeInSeconds.toFixed(1) + 's';
            
            const bytesPerFrame = 32 + (24 * player.decoder.fileHeader.totalSlaves) + (player.decoder.fileHeader.totalPixels * 4);
            const bandwidth = (bytesPerFrame * 8 * fps) / 1000000;
            document.getElementById('statusBandwidth').textContent = bandwidth.toFixed(2);
            
            document.getElementById('statusFPS').textContent = actualFps || fps;
        }
        
        function updatePlaybackStatus(status) {
            document.getElementById('playStatus').textContent = status;
        }
        
        function updateDisplayMode(mode) {
            document.getElementById('displayMode').textContent = mode;
        }
        
        function updateSlaveInfo(slaveId, decoder) {
            const infoPanel = document.getElementById('slaveInfo');
            
            if (slaveId < 0) {
                infoPanel.style.display = 'none';
                return;
            }
            
            infoPanel.style.display = 'block';
            
            try {
                const slaveInfo = decoder.getSlaveInfo(slaveId);
                
                document.getElementById('currentSlaveId').textContent = slaveId;
                document.getElementById('slaveChannels').textContent = `${slaveInfo.channelStart} - ${slaveInfo.channelEnd}`;
                document.getElementById('slavePixelCount').textContent = slaveInfo.pixelCount.toLocaleString();
                document.getElementById('slaveDataLength').textContent = `${slaveInfo.dataLength.toLocaleString()} bytes`;
                
                const config = decoder.slaveConfigs[slaveId];
                if (config) {
                    let ledTypes = '';
                    for (const section of config) {
                        const badgeClass = section.type === 'WS2812B' ? 'badge-ws2812b' : 
                                          section.type === 'STANDARD_LED' ? 'badge-standard' : 
                                          section.type === 'APA102C' ? 'badge-apa102c' : 'badge-unknown';
                        ledTypes += `<span class="led-type-badge ${badgeClass}">${section.type}</span> `;
                    }
                    document.getElementById('slaveLedTypes').innerHTML = ledTypes;
                } else {
                    document.getElementById('slaveLedTypes').textContent = 'æœªé…ç½®';
                }
            } catch (error) {
                console.error('ç„¡æ³•ç²å– Slave è³‡è¨Š:', error);
            }
        }
        
        function enableControls(enabled) {
            const controls = ['playBtn', 'pauseBtn', 'stopBtn', 'frameSlider', 'slaveSelect'];
            controls.forEach(id => {
                document.getElementById(id).disabled = !enabled;
            });
        }
        
        function showLoading(show, text = 'æ­£åœ¨è¼‰å…¥å’Œè§£ææª”æ¡ˆ...') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            
            loading.style.display = show ? 'flex' : 'none';
            loadingText.textContent = text;
        }
        
        function showErrorMessage(message) {
            alert(message);
            console.error('âŒ', message);
        }
    </script>
</body>
</html>